## 1. 进程和线程

* 进程的几种状态

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20160906192211991)

- **进程和线程的区别是什么**？

    ​	

    * 定义

      进程：进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。

      线程：线程是进程内一个相对独立的、可调度的执行单元。线程自己基本上不拥有资源，只拥有一点在运行时必不可少的资源（如程序计数器、一组寄存器和栈），但它可以与同属一个进程的其他线程共享进程拥有的全部资源。

    * 区别

      1. ==进程是资源分配的基本单位==，也是独立运行的基本单位。==线程是独立调度的基本单位==。一个进程可以包含多个线程。可以把线程看成是轻量级的进程。
      2. 线程只有一点必不可少的系统资源，线程可以访问其隶属进程的系统资源。
      3. 进程创建撤销时，系统要为之分配回收资源，开销大。进程切换时，需保存当前进程的CPU环境。而线程切换时，只需保存和设置少量寄存器内容，开销小。另外，同一进程内的多个线程共享进程的地址空间，因此多线程之间的同步与通信易于实现。 

- **进程间通信的方式有什么**？

    1. ==管道==( pipe )： 
       管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
       有名管道 (namedpipe) ： 
       有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    2. ==信号量==(semophore ) ： 
       信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    3. 消息队列( messagequeue ) ： 
       消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    4. 信号 (sinal ) ： 
       信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
    5. ==共享内存==(shared memory ) ： 
       共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    6. ==套接字==(socket ) ： 
       套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

- **线程间通信的方式有什么**？

    1. 锁机制：包括互斥锁、条件变量、读写锁 

       互斥锁提供了以排他方式防止数据结构被并发修改的方法。

       读写锁允许多个线程同时读共享数据，而对写操作是互斥的。

       条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

    2. 信号量(Semaphore)：包括无名线程信号量和命名线程信号量 

    3. 信号(Signal)：类似进程间的信号处理​      

## 2. 死锁

* 定义

  进程间因相互等待对方独占资源而引起的一种僵持状态。

* 死锁产生的原因

  系统拥有的资源数量不足、资源分配策略不当、进程对资源使用要求、并发进程推进顺序不当

* 必要条件

  互斥、不剥夺、请求与保持、环路等待

* 处理死锁

  1. 预防死锁：破坏死锁产生的四个必要条件之一
  2. 避免死锁：使系统始终处于安全状态（银行家算法）
  3. 死锁的检测与解除

- 什么是缓存？有哪些缓存的更新算法？
        这个太基础了。。。肯定得会的，缓存的更新算法用的最多的应该就是LRU。 
- 你用过什么linux命令？
        其实我用shell算是比较少的，但是一些基本上命令例如cd、ps、vim之类的。。。还是得懂的。如果你和我一样知道的不是很多应该也没关系，你记住几个最常用的，和面试官扯一扯就行了。。。你就说我用过巴拉巴拉，但是对于其他命令，其实我用得还是比较少的，因为比较少在linux上开发。我觉得你这样面试一般也会放过你的。 

## 3. 分页和分段

* 页是信息的物理单位，分页是为实现离散分配方式，以减少内存的碎片，提高内存的利用率。或者说，分页仅仅是出于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。
* 页的大小固定且由系统决定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度不固定，决定于用户所编写的程序，通常由编译系统在对源程序进行编译时根据信息的性质来划分。
* 分页系统中作业的地址空间是一维的，即单一的线性地址空间，程序员只需利用一个值来表示一个地址。分段系统中作业的地址空间是二维的，程序员在标识一个地方时，既要给出段名，又要给出段内位移。

## 4.虚拟内存

* **定义**

  基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。

* **虚拟内存技术的实现**

  请求分页式

  请求段页式

  页面替换算法：FIFO（先进先出）、LRU（最近最少使用）、OPT（最佳页面替换）、时钟页面替换

## 5. 缓存

* 定义

  凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存（Cache）。

* 缓存算法

  **最近最少使用算法（LRU）：**这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。

  **先进先出算法（FIFO）**：FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。

  **最不经常使用算法（LFU）：**这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。

  **自适应缓存替换算法(ARC)：**在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。

  **最近最常使用算法（MRU）：**这个缓存算法最先移除最近最常使用的条目。一个MRU算法擅长处理一个条目越久，越容易被访问的情况。

## 6.Linux常用命令

https://www.cnblogs.com/ccy1106/p/6637661.html



