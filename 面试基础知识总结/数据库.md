---
title: 数据库
date: 2019-04-25 21:05:31
tags: 
- 数据库
categories:
- 面试基础知识总结

---



https://blog.csdn.net/zhugewendu/article/details/73550414

## 1. 连接

- **INNER JOIN（内连接,或等值连接）**：获取两个表中字段匹配关系的记录。（默认）
- **LEFT JOIN（左连接）：**获取左表所有记录，即使右表没有对应匹配的记录。
- **RIGHT JOIN（右连接）：** 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。

## 2.事务

事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

主要有四个特性，ACID，==原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。==如果你觉得这四个特性你无法理解的话，你直接背下来这四个词就行了，然后对隔离性做深入一点的理解，其他的基本上不会被问。     

一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 3.隔离等级

**并发事务的问题**

更新丢失：两个事务都同时更新一行数据，一个事务对数据的更新把另一个事务对数据的更新覆盖了。这是因为系统没有执行任何的锁操作，因此并发并没有被隔离开来。

脏读：脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。

不可重复读：在一个事务A中多次操作一个数据，在这两次或多次访问这个数据的中间，事务B也操作此数据，并使其值发生了改变，这就导致同一个事务A在两次操作这个数据的时候值不一样，这就是不可重复读。

幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。

不可重复读和幻读比较： 两者有些相似，但是前者针对的是update，后者针对的insert或delete。

**隔离等级**

==读取未提交（Read Uncommitted）==（可以读取未提交事务的数据）：**只解决更新丢失**。如果一个事务已经开始写数据，则不允许其他事务同时进行写操作，但允许其他事务读此行数据。可通过“排他写锁”实现。

事务中的修改，即使没有提交，其他事务也可以看得到

==读取提交（Read Committed）==（读取的都是提交事务后的数据）：**解决更新丢失、脏读**。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可通过“瞬间共享读锁”和“排他写锁”实现。

大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。

==可重复读取（Repeatable Read）==（重复读这个数据也没问题）：**解决更新丢失、脏读和不可重复读取**。读取数据的事务将会禁止写事务，但允许读事务，写事务则禁止任何其他事务。可通过“共享读锁”和“排他写锁”实现。

==序列化（Serializable）==：**提供严格的事务隔离**。要求失去序列化执行，事务只能一个接一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

作为拓展，你可以记住mysql的默认隔离等级是Repeatable read，oracle的默认隔离等级是Read Committed。

## 4.存储过程

存储过程是一些预编译的SQL语句。

更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。

- 存储过程是一个预编译的代码块，执行效率比较高
- 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
- 可以一定程度上确保数据安全

## 5.视图

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

- 只暴露部分字段给访问者，所以就建一个虚表，就是视图。
- 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 6.索引

  https://kb.cnblogs.com/page/45712/

这个问题我觉得三次面试会被问到一次，基本上也是被问烂了。索引是用来加快查找速度的。MySQL中是使用B+树来实现索引的。

```reStructuredText
索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。
```

![](C:/Users/41823/Desktop/找工作/面试基础知识总结/images/索引.png)

- 索引优缺点：

  索引加快数据库的检索速度
  索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引)
  唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
  索引需要占物理和数据空间

- 索引分类：

  唯一索引：唯一索引不允许两行具有相同的索引值

  主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空

  聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个

  非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个

## 7.范式

第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。

第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

## 8.B树和B+树有什么区别？

B+树在非叶子结点不保存数据，只在叶子结点保存。而B树在叶子结点和非叶子结点都会保存。这种结构导致你如果用B树来进行查询，会增加磁盘IO的次数，导致性能不如B+树。 

## 9.什么是乐观锁，什么是悲观锁？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。

- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

  总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS（compare and swap）算法实现。

## 10.drop、delete**与**truncate的区别

SQL中的**drop、delete、truncate**都表示删除，但是三者有一些差别

- **delete和truncate**只删除表的数据不删除表的结构
- 速度,一般来说: **drop> truncate >delete** 
- **delete**语句是dml,这个操作会放到**rollback segement**中,事务提交之后才生效;
  如果有相应的**trigger**,执行的时候将被触发. **truncate,drop**是ddl, 操作立即生效,原数据不放到r**ollback segment**中,不能回滚. 操作不触发**trigger**. 

**drop、delete**与**truncate**分别在什么场景之下使用？

- 不再需要一张表的时候，用**drop**
- 想删除部分数据行时候，用**delete**，并且带上where子句
- 保留表而删除所有数据的时候用**truncate**

## 11.超键、候选键、主键、外键分别是什么？

超键（super key）：在关系中能惟一标识元素属性的集称为关系模式的超键。

候选键：（Candidate Key）：不含有多余属性的超键称为候选键。也就是说在候选键中在删除属性，就不是键了。

主键（Primary Key)：用户选作元组标识的候选键为主键。一般不加说明，键就是主键。

外键（Froeign Key）:如果模式R中的属性k是其他模式的主键，那么k在模式R中称为外键。

## 12.SQL编译的过程大概是什么样的？

这个其实是一个很有意思的问题。当时有一个面试官问我说，你直接写一堆的sql来进行数据的处理，和用一个存储过程来进行数据的处理，哪个性能更好一些。我当时没回答上来，后来面试官逐步引导我，我才回答上来的。存储过程是会在数据库中先进行编译的，所以你使用存储过程直接调用就可以了。而你如果直接写一堆的SQL语句的话，比存储过程多了一个编译的过程，所以存储过程性能好一点。然后由这个问题延伸出来一个有意思的问题。如果你了解过一些网络安全方面的知识，那你应该就听过SQL注入攻击。防止SQL注入，在jdbc中一种有效的方法就是使用prepareStatement，prepareStatement其实就是使用了预编译的方式来防止SQL注入的。 

## 13.mySQL触发器，存储过程，函数

- 存储过程

  ```sql
  --定义一个存储过程，输入参数num，输出参数str
  --将分隔符暂定为$（默认为;）
  DELIMITER $
  CREATE PROCEDURE pro_testIf(IN num INT,OUT str VARCHAR(20))
  BEGIN
      IF num=1 THEN
          SET str='星期一';
      ELSEIF num=2 THEN
          SET str='星期二';
      ELSEIF num=3 THEN
          SET str='星期三';
      ELSE
          SET str='输入错误';
      END IF;
  END $
  
  --定义一个会话变量@str接收输出参数
  --调用
  CALL pro_testIf(4,@str);
   
  SELECT @str;
  ```

- 触发器

  ```sql
  --定义一个后置触发器（Insert）
  CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW    -- 当往员工表插入一条记录时
       INSERT INTO test_log(content) VALUES('员工表插入了一条记录')
  ```

- 函数

  函数与存储过程的区别：函数**只会返回一个值**，不允许返回一个结果集。函数强调返回值，所以函数不允许返回多个值的情况，即使是查询语句。

  ```sql
  --定义函数prostdAs(...)，形参为proNam，返回值为double型
  DELIMITER ;;
  CREATE FUNCTION `prostdAs`(`proNam` varchar(255)) RETURNS double
  BEGIN
  	DECLARE r DOUBLE DEFAULT 0;
  	
  	CASE 
  	WHEN proNam='稻谷' OR proNam='水稻' OR proNam='糙米' OR proNam='大米'   
  		THEN SET r=0.2;
  	WHEN proNam='水稻' OR proNam='稻谷' OR proNam='菠菜'
  		THEN SET r=0.6;
  	ELSE SET r=0.5;
  	END CASE;
  	
  	RETURN r;
  END
  ;;
  DELIMITER ;
  ```

## 14.MySQL主从复制

​        MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

**MySQL 主从复制主要用途：**读写分离；数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换

**基本流程，3个线程以及之间的关联：**

1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
3. 从：sql执行线程——执行relay log中的语句；

## 15.MySQL引擎Innodb和MyISAM区别

- Innodb支持事务、外键，而MyISAM不支持
- Innodb是行级锁，MyISAM是表级锁
- Innodb的主键索引是聚集索引，而MyISAM是非聚集索引
- MyISAM保存了表的总行数，而Innodb没有

