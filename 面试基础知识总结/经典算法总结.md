---
title: 经典算法总结
date: 2019-07-18 22:33:31
tags: 
- 算法
categories:
- 算法

---

# 动态规划

## 1.0-1背包问题

假设物品共有n个，背包的承重总量为m，第i个物品的重量是wi，价值是pi。

用Ti(j)表示前*i*个物品有选择地放入载重量为*j*的背包中的最大价值。有如下递推关系：

![1567607144173](images\01背包.png)

当第i个物品的重量大于背包重量时，可以不考虑这个物品；相反，可以分为第i个物品放入背包和不放入背包两种情况：不能放入时，变为前(i-1)个物品的背包问题；能放入时，变为前(i-1)个物品的、背包承重量减少wi的背包问题。因此，使用一个i行j列的数组保存Ti(j)对应的价值。

```java
public int knapsack(int[] weight, int[] value, int maxweight){
        int n = weight.length;
        //最大价值数组为maxvalue[N+1][maxWeight+1]，因为我们要从0开始保存
        int[][] maxvalue = new int[n+1][maxweight + 1];
        //重量和物品为0时，价值为0
        for (int i = 0; i < maxweight + 1; i++) maxvalue[0][i] = 0;
        for (int i = 0; i < n + 1; i++)  maxvalue[i][0] = 0;
        //i：只拿前i件物品      
        //j：当前背包总重量为j
        //n是物品件数
        for (int i = 1; i <= n ; i++) {
            for (int j = 1; j <= maxweight; j++) {
                //如果当前件的重量小于总重量，可以放进去或者拿出别的东西再放进去或者不放进去
                //因为weight和value都是从下标0开始，因此第i个物品就是weight[i-1]
                if (weight[i-1] <= j) {
                    //比较（不放这个物品的价值）和
                    //（这个物品的价值 加上 当前能放的总重量减去当前物品重量时取前i-1个物品时的对应重量时                     //候的最高价值）
                    maxvalue[i][j] = Math.max(maxvalue[i-1][j - weight[i-1]] + value[i-1],maxvalue[i-1][j]);
                }else {
                    //当前物品价值大于当前背包重量，丢掉
                	maxvalue[i][j] = maxvalue[i-1][j];
                }
            }
        }
        return maxvalue[n][maxweight];
    }
```

## 2.斐波那契数列



### 矩形覆盖



### 青蛙跳台阶



### 变态跳台阶

## 3.最大连续子序列和

[牛客]: https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking

​	给定一个序列，找出有最大和的子序列，强调子序列必须是连续的。例如：数组{1，-2,3,10，-4,7,2，-5}的最大子数组{3,10，-4,7,2}的和为18。

​	此题使用动态规划求解，遍历数组，找出以当前元素结尾的子序列的最大和，并记录在dp数组中。状态转移方程为：dp[i]=max{array[i],dp[i-1]+array[i]}

```java
    //动态规划：dp[i]表示以array[i]结尾的子串的最大和
    //dp[i]=max{array[i],dp[i-1]+array[i]}
    //最后找到dp数组中的最大值即可
    public int FindGreatestSumOfSubArray(int[] array) {
        if(array == null || array.length <= 0) return 0;
        int maxSum = Integer.MIN_VALUE;
        int[] dp = new int[array.length];
        dp[0] = array[0];
        for (int i = 1; i < array.length; i++) {
            dp[i] = Math.max(array[i],dp[i-1] + array[i]);
            maxSum = Math.max(dp[i], maxSum);
        }
        return maxSum;
    }
```

## 4.最长递增子序列

[领扣]: https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/#comment
[LeetCode]: https://leetcode.com/articles/longest-increasing-subsequence/

子序列不一定是连续的，只要递增即可。

1. **方法一：动态规划（略暴力）。**

​	创建数组dp[]，dp[i]表示以nums[i]结尾的递增子序列的长度。当遍历到nums[i]时，在它前面的元素中找到一个元素nums[j]（满足0<j<i，nums[j]<nums[i]且dp[j]在前面的元素中是最大的），因此以nums[j]结尾的递增子序列加上nums[i]构成一个新的递增子序列，长度加一。

​	状态转移方程为：dp[i]=max(dp[j])+1,∀0≤j<i,nums[j]<nums[i]

```java
public int lengthOfLIS(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    int[] dp = new int[nums.length];
    dp[0] = 1;
    int maxans = 1; //记录最长的递增子序列的长度
    for (int i = 1; i < dp.length; i++) {
        int maxval = 0;
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                maxval = Math.max(maxval, dp[j]);
            }
        }
        dp[i] = maxval + 1;
        maxans = Math.max(maxans, dp[i]);  //dp数组中最大的值即为递增子序列的最大长度
    }
    return maxans;
}
```

2. **动态规划+二分查找**

   ​        扫描整个数组，dp数组保存当前元素之前的序列中已经找到的递增子序列，因此dp数组是有序的。每次扫描到一个元素时，找到dp数组中第一个大于该元素的数，并替换它，如果该元素大于dp数组中最大的那个元素，则直接添加到dp数组尾部。

```java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    int len = 0;
    for (int num : nums) {
        int i = Arrays.binarySearch(dp, 0, len, num);   //二分查找返回查找到的数的下标，如果没有，返回
        if (i < 0) {                                    //第一个大于该数的元素的下标值（负的）。
            i = -(i + 1);
        }
        dp[i] = num;
        if (i == len) {
            len++;
        }
    }
    return len;
}
```

